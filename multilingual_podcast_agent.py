# -*- coding: utf-8 -*-
"""multilingual_podcast_agent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-emHDdKBc183wrOSFA3JTPDe2BfYs1hr

# **IA - ADK - Podcast**
**By:** Bernal Alarcón Brandón Yahir

**Result:** The designed agent is capable of generating a podcast from a **PDF file** or from any given topic. You can choose between **1 or 2 speakers**, the language can be **Spanish, English, Portuguese, French, ...,** and the gender and voice can be selected between **male or female**, including adjustments to voice tone.

(Languages and available voices are detailed in the execution cell.)

---
**Comments:** The execution process is somewhat rudimentary due to the limitations of the notebook environment. If deployed in a virtual environment using a web-based ADK or similar setup, minor modifications would be required.

#**Code Structure**

## **Agent Development**
"""

# Commented out IPython magic to ensure Python compatibility.
#@title Install ADK
# %pip install -q -U google-adk google-genai pdfplumber

#@title Importing Libraries and Modules

import asyncio
import pdfplumber
import wave
import os
import logging
from IPython.display import Audio, display
import re


from google import genai
from google.genai import types

from google.adk.agents import Agent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.adk.tools import FunctionTool

#@title API KEY
os.environ["GOOGLE_API_KEY"] = "AQUI VA TU API KEY"
os.environ["GOOGLE_GENAI_USE_VERTEXAI"] = "False"
logging.getLogger("google_genai.types").setLevel(logging.ERROR)

#@title Herramientas para el Agent()

# Extrae la información del pdf para trabajarla con nuestro agente

def extraer_texto_pdf(pdf_path: str) -> str:
    """Devuelve el texto del PDF (todas las páginas concatenadas)."""
    with pdfplumber.open(pdf_path) as pdf:
        texto = ""
        for p in pdf.pages:
            t = p.extract_text() or ""
            texto += t + "\n"
    return texto

# Define el archivo que se creará

def wave_file(filename, pcm, channels=1, rate=24000, sample_width=2):
    with wave.open(filename, "wb") as wf:
        wf.setnchannels(channels)
        wf.setsampwidth(sample_width)
        wf.setframerate(rate)
        wf.writeframes(pcm)

# Nos perimte asignarle voz al guion creado
"""
Convierte un guion con Speaker1/Speaker2 en WAV.
Soporta un encabezado opcional en la primera línea:
#VOICES: Speaker1=<VoiceName>, Speaker2=<VoiceName>, ...
Si no se especifica, usa por defecto: Speaker1=Kore, Speaker2=Puck.
"""

def VOZ(texto: str) -> str:
    client = genai.Client(api_key=os.getenv("GOOGLE_API_KEY"))

    # Ayuda a asignar las #VOICES
    lines = texto.splitlines()
    voice_map = {}
    if lines and lines[0].strip().upper().startswith("#VOICES:"):
        header = lines[0].split(":", 1)[1]
        for pair in header.split(","):
            if "=" in pair:
                k, v = pair.split("=", 1)
                spk = k.strip()
                vname = v.strip()
                if spk and vname:
                    voice_map[spk] = vname
        texto = "\n".join(lines[1:])

    # Si no se especifica
    if not voice_map:
        voice_map = {"Speaker1": "Kore", "Speaker2": "Puck"}

    # Ocupamos la API de gemini Speech generation (text-to-speech) para generar el audio

    voice_cfgs = []
    for spk, vname in voice_map.items():
        voice_cfgs.append(
            types.SpeakerVoiceConfig(
                speaker=spk,
                voice_config=types.VoiceConfig(
                    prebuilt_voice_config=types.PrebuiltVoiceConfig(voice_name=vname)
                )
            )
        )

    try:
        resp = client.models.generate_content(
            model="gemini-2.5-flash-preview-tts",
            contents=texto,
            config=types.GenerateContentConfig(
                response_modalities=["AUDIO"],
                speech_config=types.SpeechConfig(
                    multi_speaker_voice_config=types.MultiSpeakerVoiceConfig(
                        speaker_voice_configs=voice_cfgs
                    )
                )
            )
        )
        data = resp.candidates[0].content.parts[0].inline_data.data
        file_name = "podcast.wav"
        wave_file(file_name, data)
        return file_name
    except Exception as e:
        return f"Error en VOZ(): {e}"

tool_extraer_pdf = FunctionTool(func=extraer_texto_pdf)
tool_convertir_voz = FunctionTool(func=VOZ)

#@title Agent()

# Nuestro agente principal, estructura base del ADK y con la que se controla todo el proceso

agent_head = Agent(
    name="AgenteCabeza",
    model="gemini-2.5-flash",
    description="Lee PDF, guioniza (Speaker1/Speaker2) y genera audio WAV. También puede guionizar sin PDF según idioma/género/cantidad de voces solicitadas por el usuario.",
    tools=[tool_extraer_pdf, tool_convertir_voz],
    instruction=(
        "Flujo ESTRICTO:\n"
        "1) Si el mensaje incluye una RUTA de PDF existente, llama a extraer_texto_pdf(pdf_path) y usa ese texto como base temática, entiende la solicitud del usuario (idioma, número de voces y género: hombre/mujer/mixto) y genera un GUION acorde al pedido y el pdf.\n"
        "2) Si el mensaje NO incluye PDF, entiende la solicitud del usuario (idioma, número de voces y género: hombre/mujer/mixto) y genera un GUION acorde al pedido.\n"
        "3) Eres un asistente creativo y con alto analisis, Usa modismos del idioma para crear el guión, se creativo no te limites, haz que parezca una conversación y natural. \n"
        "4) Siempre produce la salida en este formato EXACTO, (si se pide una sola voz o una persona solo usa Speaker1 y el Speaker2 solo dirá -Nos vemos- y se le asinfna misma voz que el Speaker1, si te pido 2 voces usarás Speaker1 y Speaker2) sin prólogos ni explicaciones:\n"
        "   #VOICES: Speaker1=<VoiceName>[, Speaker2=<VoiceName>[, ...]]\n"
        "   Speaker1: ...\n"
        "   Speaker2: ...\n"
        "5) Selección de voces para la línea #VOICES: por defecto usa Puck para voz masculina y Kore para voz femenina. Si el usuario especifica otras voces por nombre, respétalas.\n"
        "6) Tras redactar el guion, llama a VOZ(guion) para convertirlo a audio WAV.\n"
        "7) Devuelve SOLO un breve resumen (1-2 líneas) y el nombre del archivo WAV resultante.\n"
        "8) El idioma del guion debe coincidir con el pedido del usuario (p. ej., inglés o español)."
    ),
)

#@title Sesion()

# Se crea una sesion para poder ejecutar al agente

session_service = InMemorySessionService()
APP_NAME = "Podcast"
USER_ID = "user_1"
SESSION_ID = "session_solo_cabeza"

try:
    session = await session_service.create_session(
        app_name=APP_NAME, user_id=USER_ID, session_id=SESSION_ID
    )
except TypeError:
    session = session_service.create_session(
        app_name=APP_NAME, user_id=USER_ID, session_id=SESSION_ID
    )

runner = Runner(agent=agent_head, app_name=APP_NAME, session_service=session_service)

# maneja tool calls y respuesta final
async def call_agent_async(query: str, runner: Runner, user_id: str, session_id: str):
    content = types.Content(role="user", parts=[types.Part(text=query)])
    final_text = []
    async for event in runner.run_async(user_id=user_id, session_id=session_id, new_message=content):
        # Si tu versión de ADK expone evento de tool, deja que lo ejecute
        if hasattr(event, "tool_request") and event.tool_request:
            await event.call_tool()
        elif event.is_final_response():
            if event.content and event.content.parts:
                final_text.append("".join(getattr(p, "text", "") for p in event.content.parts))
            break
    return "\n".join(final_text).strip() if final_text else "Sin texto final en la respuesta."

#@title Funcion para ejecución sencilla

# Sirve para llamar al agente de una forma más simple

async def Ejecutar_agente(
    speakers: int,
    voces: list,
    idioma: str,
    tiempo: str,
    tema: str | None = None,
    pdf_path: str | None = None
):
    """
    Ejecuta tu agente con parámetros completos.
    - Si pasas pdf_path (o pones tema en {'el pdf','NA','N/A',''}), usa el PDF como base temática.
    - Si no hay pdf_path, usa el 'tema' indicado para el guión.

    Parámetros:
      speakers : número de voces (1 o 2)
      voces    : lista de nombres de voces (len == speakers), ej. ["Kore","Chester"]
      idioma   : idioma del guion ("español", "inglés", "portugués")
      tiempo   : duración ("1 minuto", "2 minutos")
      tema     : tema del guion (si no usas PDF). Puedes pasar "el pdf"/"NA"/"N/A" si usas pdf_path
      pdf_path : ruta del PDF a procesar (opcional)
    """

    # asigna SpeakerN=VozN
    voces_str = ", ".join([f"Speaker{i+1}={v}" for i, v in enumerate(voces)])

    # Determina si usa un pdf o no
    tema_norm = (tema or "").strip().lower()
    usar_pdf = bool(pdf_path) and (tema_norm in ("", "el pdf", "na", "n/a"))

    if usar_pdf:
        consulta = (
            f"Procesa este PDF y regresa el texto: {pdf_path}\n"
            f"Luego, genera un guion a partir del pdf de {tiempo} en {idioma} con {speakers} voces.\n"
            f"Asigna así las voces: {voces_str}."
        )
    else:
        consulta = (
            f"Haz un guion de {tiempo} en {idioma} sobre {tema} "
            f"con {speakers} voces. "
            f"Asigna así las voces: {voces_str}."
        )

    # Llamada a tu agente
    salida = await call_agent_async(
        consulta, runner=runner, user_id=USER_ID, session_id=SESSION_ID
    )

    #print("\nSalida del agente:")
    #print(salida)

    # Reproducir el WAV si existe
    audio_path = "podcast.wav"
    if os.path.exists(audio_path):
        display(Audio(filename=audio_path, autoplay=False))
    else:
        print("\nNo se encontró el audio. Revisa la salida del agente o errores.")

    return salida

"""# **Execution Code**

You must update your GOOGLE API KEY in the section:
Code Structure / API KEY

Please review the execution process carefully. You only need to modify the prompt. The simplified execution mode is more intuitive and is the one I recommend for experimentation.

If you are working with a PDF file, you must upload it to the Colab environment and copy its file path.

## **Configuración audio e idioma**

###**Voz**

En teoría, podrían funcionar todas estas voces, si alguna falla, cambiemos a otra, esto puede deberse a modificaciones o actualizaciones de genai

**Hombres**

Puck – Optimista

Caronte – Informativo

Fenrir – Excitable

Orus – Firm

Jápeto – Claro

Umbriel – Tranquilo

Algenib – Grave (Gravelly)

Rasalgethi – Informativo

Gacrux – Maduro

Zubenelgenubi – Casual

Sadaltager – Conocedor

---

**Mujeres**

Céfiro – Brillante

Kore – Firm

Leda – Juvenil

Aoede – Ventoso

Callirrhoe – Tranquilo

Autónomo – Brillante

Encélado – Respirable

Algieba – Suave

Despina – Suave

Erinome – Claro

Laomedeia – Optimista

Achernar – Suave

Alnilam – Firm

Schedar – Incluso (Even)

Pulcherrima – Adelante

Achird – Amistoso

Vindemiatrix – Gentil

Sadachbia – Vivaz

Sulafat – Caliente

### **Idioma**

Ocurre lo mismo para los Idiomas, pueden funcionar cualquiera de estos, sin embargo, puede que en algun momento, algunos ya no funcionen

Portugués (Brazil)

Alemán (Alemania)

Inglés (EE. UU.)

Español (EE. UU.)

Portugués (Brasil)

Francés (Francia)

Hindi (India)

Indonesio (Indonesia)

Italiano (Italia)

Japonés (Japón)

Coreano (Corea)

Árabe (Egipto)

Ruso (Rusia)

Holandés (Países Bajos)

Polaco (Polonia)

Tailandés (Tailandia)

Turco (Turquía)

Vietnamita (Vietnam)

Rumano (Rumania)

Ucraniano (Ucrania)

Bengalí (Bangladesh)

Inglés (India)

Maratí (India)

Tamil (India)

Telugu (India)

##**Ejecución base**

Aquí podemos editar aspectos extras darle más instinstrucciones a mi agente
"""

#@title Ejemplo 1 - Por defecto, solo pasamos el pdf

pdf_path = "/content/sample_data/Sesion1.pdf"

# Caso 1 solo pasar el PDF Por defecto ocupa 2 voces, una hombre y una mujer en español
salida_agente_pdf = await call_agent_async(
    f"Procesa este PDF y regresa audio: {pdf_path}",
    runner=runner, user_id=USER_ID, session_id=SESSION_ID,
)
print("Salida del agente (PDF):")
print(salida_agente_pdf)

audio_path = "podcast.wav"
if os.path.exists(audio_path):
    display(Audio(filename=audio_path, autoplay=False))
else:
    print("\nNo se encontró el audio. Revisa la salida del agente o errores.")

#@title Ejemplo 2 - modifmodificar comentarios, idioma y tema

consulta = (
    "Haz un guion de 1 minuto en Inglés sobre técnicas de estudio "
    "con una sola voz"
    "Asigna la voz Aoede"
)

salida_agente = await call_agent_async(
    consulta, runner=runner, user_id=USER_ID, session_id=SESSION_ID
)

print(salida_agente)

audio_path = "podcast.wav"
if os.path.exists(audio_path):
    display(Audio(filename=audio_path, autoplay=False))
else:
    print("\nNo se encontró el audio. Revisa la salida del agente o errores.")

"""##**Ejecución sencilla**

Aquí solo agregamos los parámetros de la funcion y se hace solo el prompt que le damos al agente, este formato es mas rigido, pues solo cambiamos los parámetros

```
await Ejecutar_agente(
  speakers= [1 o 2], # numero de comentaristas
  voces=["Kore", "Charon"], # Sexo y voz de las personas
  idioma="Español", # Idioma
  tiempo="1 minuto", #Tiempo estimado, no es exacto, pero ayuda a controlarlo
  tema="el pdf",  # Si usamos el pdf usamos "el pdf" en otro caso el tema a usar para el podcast
  pdf_path="/content/sample_data/Sesion1.pdf" # si hay pdf colocamos su ruta
   )
```

Si aparece un error, correlo de nuevo
"""

#@title Ejemplo 2 personas (hombre y mujer) en español a partir de un pdf

await Ejecutar_agente(
    speakers=2,
    voces=["Kore", "Charon"],
    idioma="Español",
    tiempo="1 minuto",
    tema="el pdf",
    pdf_path="/content/sample_data/Sesion1.pdf"
)

#@title Ejemplo dos veces en portugués, tema "Balon de oro en el fútbol"

await Ejecutar_agente(
    speakers=2,
    voces=["Kore", "Charon"],
    idioma="Portugués",
    tiempo="1 minuto",
    tema="Balon de oro en el fútbol"
    #pdf_path="/content/sample_data/Sesion1.pdf"
)

#@title Ejemplo Una persona, hombre en japonés

await Ejecutar_agente(
    speakers=1,
    voces=["Charon"],
    idioma="Japonés",
    tiempo="1 minuto",
    tema="Machine learning"
)